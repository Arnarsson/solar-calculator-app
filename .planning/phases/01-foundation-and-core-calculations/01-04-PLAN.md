---
phase: 01-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - app/api/calculate/route.ts
  - app/api/calculate/projection/route.ts
  - lib/utils/serialization.ts
  - lib/api/pvgis.ts
  - app/providers.tsx
autonomous: true

must_haves:
  truths:
    - "API routes accept calculation inputs and return serialized Decimal results"
    - "PVGIS integration provides solar yield estimates based on location"
    - "TanStack Query provider configured for client-side data fetching"
  artifacts:
    - path: "app/api/calculate/route.ts"
      provides: "Main calculation API endpoint"
      exports: ["POST"]
    - path: "lib/utils/serialization.ts"
      provides: "Decimal serialization utilities"
      exports: ["serializeDecimal", "serializeProjection"]
    - path: "lib/api/pvgis.ts"
      provides: "PVGIS solar irradiance integration"
      exports: ["fetchPVGISData", "calculateAnnualProduction"]
  key_links:
    - from: "app/api/calculate/route.ts"
      to: "lib/calculations/projection.ts"
      via: "imports calculation functions"
      pattern: "import.*from.*calculations"
    - from: "app/api/calculate/route.ts"
      to: "lib/utils/serialization.ts"
      via: "serializes Decimal for JSON response"
      pattern: "serialize"
---

<objective>
Create API routes for calculations with proper Decimal serialization and PVGIS integration.

Purpose: Client components cannot use Decimal objects directly (serialization error). API routes perform calculations server-side and return JSON-serializable results. PVGIS provides location-based solar yield estimates.

Output: Working API endpoints that client components can fetch from using TanStack Query.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-and-core-calculations/01-RESEARCH.md

@lib/calculations/projection.ts (from Plan 03)
@lib/calculations/payback.ts (from Plan 02)
@lib/api/open-meteo.ts (existing pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Decimal serialization utilities</name>
  <files>
    lib/utils/serialization.ts
  </files>
  <action>
Create lib/utils/serialization.ts with utilities to convert Decimal results to JSON-safe formats:

```typescript
import Decimal from 'decimal.js';
import { YearResult, ProjectionResult, ProjectionSummary } from '@/lib/calculations/projection';
import { PaybackResult } from '@/lib/calculations/payback';
import { SetupCostResult } from '@/lib/calculations/setupPricing';
import { TaxScenarioResult } from '@/lib/calculations/taxScenarios';

/**
 * Serialize a single Decimal to string with full precision
 */
export function serializeDecimal(d: Decimal): string {
  return d.toFixed();
}

/**
 * Serialize a Decimal to number (for charts)
 * WARNING: May lose precision for very large/small numbers
 */
export function serializeDecimalToNumber(d: Decimal): number {
  return d.toNumber();
}

/**
 * Serialize a Decimal with fixed decimal places (for display)
 */
export function serializeDecimalFixed(d: Decimal, places: number = 2): string {
  return d.toFixed(places);
}

// Serialized type definitions (what API returns)
export interface SerializedPaybackResult {
  annualSavings: string;
  selfConsumptionSavings: string;
  gridExportEarnings: string;
  paybackYears: string;
  breakEvenYear: number;
}

export interface SerializedYearResult {
  year: number;
  productionKwh: string;
  electricityRate: string;
  savingsNominal: string;
  savingsReal: string;
  maintenanceCost: string;
  netSavingsNominal: string;
  netSavingsReal: string;
  cumulativeNominal: string;
  cumulativeReal: string;
}

export interface SerializedProjectionSummary {
  totalSavingsNominal: string;
  totalSavingsReal: string;
  totalMaintenanceCost: string;
  breakEvenYearNominal: number;
  breakEvenYearReal: number;
  roi25Year: string;
}

export interface SerializedProjectionResult {
  years: SerializedYearResult[];
  summary: SerializedProjectionSummary;
}

export interface SerializedSetupCostResult {
  panelsCost: string;
  inverterCost: string;
  installationCost: string;
  mountingKitCost: string;
  batteryCost: string;
  subtotal: string;
  vatRate: string;
  vatAmount: string;
  totalWithVat: string;
}

export interface SerializedTaxScenarioResult {
  scenario: string;
  eligibleAmount: string;
  deductionRate: string;
  taxDeduction: string;
  maxDeduction: string;
  effectiveCost: string;
  effectivePaybackYears: string;
  assumptions: string[];
}

// Serializer functions
export function serializePayback(result: PaybackResult): SerializedPaybackResult {
  return {
    annualSavings: serializeDecimalFixed(result.annualSavings),
    selfConsumptionSavings: serializeDecimalFixed(result.selfConsumptionSavings),
    gridExportEarnings: serializeDecimalFixed(result.gridExportEarnings),
    paybackYears: serializeDecimalFixed(result.paybackYears),
    breakEvenYear: result.breakEvenYear,
  };
}

export function serializeProjection(result: ProjectionResult): SerializedProjectionResult {
  return {
    years: result.years.map(y => ({
      year: y.year,
      productionKwh: serializeDecimalFixed(y.productionKwh),
      electricityRate: serializeDecimalFixed(y.electricityRate, 4),
      savingsNominal: serializeDecimalFixed(y.savingsNominal),
      savingsReal: serializeDecimalFixed(y.savingsReal),
      maintenanceCost: serializeDecimalFixed(y.maintenanceCost),
      netSavingsNominal: serializeDecimalFixed(y.netSavingsNominal),
      netSavingsReal: serializeDecimalFixed(y.netSavingsReal),
      cumulativeNominal: serializeDecimalFixed(y.cumulativeNominal),
      cumulativeReal: serializeDecimalFixed(y.cumulativeReal),
    })),
    summary: {
      totalSavingsNominal: serializeDecimalFixed(result.summary.totalSavingsNominal),
      totalSavingsReal: serializeDecimalFixed(result.summary.totalSavingsReal),
      totalMaintenanceCost: serializeDecimalFixed(result.summary.totalMaintenanceCost),
      breakEvenYearNominal: result.summary.breakEvenYearNominal,
      breakEvenYearReal: result.summary.breakEvenYearReal,
      roi25Year: serializeDecimalFixed(result.summary.roi25Year),
    },
  };
}

export function serializeSetupCost(result: SetupCostResult): SerializedSetupCostResult {
  return {
    panelsCost: serializeDecimalFixed(result.panelsCost),
    inverterCost: serializeDecimalFixed(result.inverterCost),
    installationCost: serializeDecimalFixed(result.installationCost),
    mountingKitCost: serializeDecimalFixed(result.mountingKitCost),
    batteryCost: serializeDecimalFixed(result.batteryCost),
    subtotal: serializeDecimalFixed(result.subtotal),
    vatRate: serializeDecimalFixed(result.vatRate, 4),
    vatAmount: serializeDecimalFixed(result.vatAmount),
    totalWithVat: serializeDecimalFixed(result.totalWithVat),
  };
}

export function serializeTaxScenario(result: TaxScenarioResult): SerializedTaxScenarioResult {
  return {
    scenario: result.scenario,
    eligibleAmount: serializeDecimalFixed(result.eligibleAmount),
    deductionRate: serializeDecimalFixed(result.deductionRate, 4),
    taxDeduction: serializeDecimalFixed(result.taxDeduction),
    maxDeduction: serializeDecimalFixed(result.maxDeduction),
    effectiveCost: serializeDecimalFixed(result.effectiveCost),
    effectivePaybackYears: serializeDecimalFixed(result.effectivePaybackYears),
    assumptions: result.assumptions,
  };
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - serialization module compiles without errors.
  </verify>
  <done>
Serialization utilities convert all Decimal results to JSON-safe string format. Typed interfaces for serialized results ensure type safety across API boundary.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create calculation API route and PVGIS integration</name>
  <files>
    app/api/calculate/route.ts
    app/api/calculate/projection/route.ts
    lib/api/pvgis.ts
  </files>
  <action>
Create lib/api/pvgis.ts for solar yield estimation:

```typescript
import Decimal from 'decimal.js';

export interface PVGISParams {
  latitude: number;
  longitude: number;
  peakPowerKw: number;     // System size in kW
  azimuth: number;          // Degrees from north (180 = south)
  tilt: number;             // Panel tilt angle
  systemLoss?: number;      // Default 14% (cables, inverter, etc.)
}

export interface PVGISResponse {
  annualProductionKwh: Decimal;
  monthlyProduction: { month: number; kWh: Decimal }[];
  optimalTilt: number;
  optimalAzimuth: number;
}

const PVGIS_BASE_URL = 'https://re.jrc.ec.europa.eu/api/v5_2/PVcalc';

/**
 * Fetch solar production estimate from EU PVGIS API
 *
 * Rate limit: 30 req/sec - use caching for repeated queries
 */
export async function fetchPVGISData(params: PVGISParams): Promise<PVGISResponse> {
  const systemLoss = params.systemLoss ?? 14;

  const url = new URL(PVGIS_BASE_URL);
  url.searchParams.set('lat', params.latitude.toString());
  url.searchParams.set('lon', params.longitude.toString());
  url.searchParams.set('peakpower', params.peakPowerKw.toString());
  url.searchParams.set('loss', systemLoss.toString());
  url.searchParams.set('angle', params.tilt.toString());
  url.searchParams.set('aspect', (params.azimuth - 180).toString()); // PVGIS uses -180 to 180
  url.searchParams.set('outputformat', 'json');

  const response = await fetch(url.toString(), {
    next: { revalidate: 86400 }, // Cache for 24 hours
  });

  if (!response.ok) {
    throw new Error(`PVGIS API error: ${response.status}`);
  }

  const data = await response.json();

  // Parse PVGIS response
  const annualProductionKwh = new Decimal(data.outputs.totals.fixed.E_y);

  const monthlyProduction = data.outputs.monthly.fixed.map((m: any, idx: number) => ({
    month: idx + 1,
    kWh: new Decimal(m.E_m),
  }));

  return {
    annualProductionKwh,
    monthlyProduction,
    optimalTilt: data.inputs.mounting_system.fixed.slope.opt ?? params.tilt,
    optimalAzimuth: (data.inputs.mounting_system.fixed.azimuth.opt ?? 0) + 180,
  };
}

/**
 * Estimate annual production from roof area and efficiency
 * Fallback when PVGIS unavailable or for quick estimates
 */
export function estimateProductionFromArea(
  roofAreaM2: Decimal,
  efficiencyPercent: Decimal = new Decimal('20'), // Modern panel ~20%
  sunHoursPerYear: Decimal = new Decimal('950')    // Denmark average
): Decimal {
  // kWh = Area * Efficiency * Sun Hours * Performance Ratio (0.8)
  const performanceRatio = new Decimal('0.8');
  return roofAreaM2
    .times(efficiencyPercent.dividedBy(100))
    .times(sunHoursPerYear)
    .times(performanceRatio);
}
```

Create app/api/calculate/route.ts for main calculation endpoint:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import Decimal from 'decimal.js';
import { calculateSetupCost } from '@/lib/calculations/setupPricing';
import { calculatePayback } from '@/lib/calculations/payback';
import { calculateTaxScenario, compareTaxScenarios } from '@/lib/calculations/taxScenarios';
import {
  serializeSetupCost,
  serializePayback,
  serializeTaxScenario,
} from '@/lib/utils/serialization';
import { fetchPVGISData, estimateProductionFromArea } from '@/lib/api/pvgis';

export interface CalculateRequest {
  // Location
  latitude: number;
  longitude: number;
  priceArea: 'DK1' | 'DK2';

  // Roof
  roofAreaM2: number;
  azimuthDegrees: number;
  tiltDegrees: number;

  // System costs
  panelsCost: number;
  inverterCost: number;
  installationCost: number;
  mountingKitCost: number;

  // Energy
  electricityRateDkk: number;
  selfConsumptionRate: number;
}

export async function POST(request: NextRequest) {
  try {
    const body: CalculateRequest = await request.json();

    // 1. Calculate setup cost
    const setupCost = calculateSetupCost({
      panelsCost: new Decimal(body.panelsCost),
      inverterCost: new Decimal(body.inverterCost),
      installationCost: new Decimal(body.installationCost),
      mountingKitCost: new Decimal(body.mountingKitCost),
    });

    // 2. Estimate annual production
    // First try PVGIS, fallback to area-based estimate
    let annualProductionKwh: Decimal;
    let productionSource: 'pvgis' | 'estimate';

    try {
      const pvgisData = await fetchPVGISData({
        latitude: body.latitude,
        longitude: body.longitude,
        peakPowerKw: new Decimal(body.roofAreaM2).times('0.2').toNumber(), // ~200W/m2
        azimuth: body.azimuthDegrees,
        tilt: body.tiltDegrees,
      });
      annualProductionKwh = pvgisData.annualProductionKwh;
      productionSource = 'pvgis';
    } catch (error) {
      // Fallback to estimate
      annualProductionKwh = estimateProductionFromArea(new Decimal(body.roofAreaM2));
      productionSource = 'estimate';
    }

    // 3. Calculate payback
    const gridFeedInRate = new Decimal(body.electricityRateDkk).times('0.8');
    const payback = calculatePayback({
      systemCost: setupCost.totalWithVat,
      annualProductionKwh,
      electricityRate: new Decimal(body.electricityRateDkk),
      selfConsumptionRate: new Decimal(body.selfConsumptionRate),
      gridFeedInRate,
    });

    // 4. Calculate tax scenarios
    const taxScenarios = compareTaxScenarios({
      systemCost: setupCost.totalWithVat,
      installationLaborCost: new Decimal(body.installationCost),
      panelsCost: new Decimal(body.panelsCost),
      inverterCost: new Decimal(body.inverterCost),
      annualSavings: payback.annualSavings,
    });

    // 5. Return serialized results
    return NextResponse.json({
      setupCost: serializeSetupCost(setupCost),
      annualProductionKwh: annualProductionKwh.toFixed(2),
      productionSource,
      payback: serializePayback(payback),
      taxScenarios: taxScenarios.map(serializeTaxScenario),
    });
  } catch (error) {
    console.error('Calculation error:', error);
    return NextResponse.json(
      { error: 'Calculation failed', message: (error as Error).message },
      { status: 500 }
    );
  }
}
```

Create app/api/calculate/projection/route.ts for 25-year projection:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import Decimal from 'decimal.js';
import { calculateProjection } from '@/lib/calculations/projection';
import { serializeProjection } from '@/lib/utils/serialization';

export interface ProjectionRequest {
  systemCost: number;
  annualProductionKwh: number;
  electricityRateDkk: number;
  selfConsumptionRate: number;
  gridFeedInRate: number;
  inflationRate?: number;
  electricityInflationRate?: number;
  maintenanceCostYear1?: number;
}

export async function POST(request: NextRequest) {
  try {
    const body: ProjectionRequest = await request.json();

    const projection = calculateProjection({
      systemCost: new Decimal(body.systemCost),
      annualProductionKwh: new Decimal(body.annualProductionKwh),
      electricityRateDkk: new Decimal(body.electricityRateDkk),
      selfConsumptionRate: new Decimal(body.selfConsumptionRate),
      gridFeedInRate: new Decimal(body.gridFeedInRate),
      inflationRate: new Decimal(body.inflationRate ?? 0.02),
      electricityInflationRate: new Decimal(body.electricityInflationRate ?? 0.03),
      maintenanceCostYear1: new Decimal(body.maintenanceCostYear1 ?? 1000),
      degradationRateFirstYear: new Decimal('0.03'),
      degradationRateAnnual: new Decimal('0.005'),
    });

    return NextResponse.json(serializeProjection(projection));
  } catch (error) {
    console.error('Projection calculation error:', error);
    return NextResponse.json(
      { error: 'Projection failed', message: (error as Error).message },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - all API routes compile.
Run `npm run build` - build completes without errors.
  </verify>
  <done>
API routes created for main calculation and 25-year projection. PVGIS integration fetches location-based solar yield with 24-hour caching. All Decimal results serialized to JSON-safe strings.
  </done>
</task>

<task type="auto">
  <name>Task 3: Set up TanStack Query provider for client-side fetching</name>
  <files>
    app/providers.tsx
    app/layout.tsx
  </files>
  <action>
Create app/providers.tsx with TanStack Query setup:

```typescript
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { useState, type ReactNode } from 'react';

export function Providers({ children }: { children: ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // Calculation results are deterministic - cache aggressively
            staleTime: 5 * 60 * 1000, // 5 minutes
            gcTime: 30 * 60 * 1000,   // 30 minutes (formerly cacheTime)
            refetchOnWindowFocus: false,
            retry: 1,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )}
    </QueryClientProvider>
  );
}
```

Update app/layout.tsx to wrap with Providers:

Read the existing layout.tsx first, then wrap the body content with the Providers component:

```typescript
import { Providers } from './providers';

// ... existing imports and metadata ...

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="da">
      <body className={/* existing classes */}>
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
```

Install TanStack Query devtools:
```bash
npm install @tanstack/react-query-devtools
```
  </action>
  <verify>
Run `npm run dev` - app starts without errors.
Open browser devtools - React Query devtools panel available (in dev mode).
  </verify>
  <done>
TanStack Query provider configured with appropriate caching for calculation results. Devtools available in development for debugging queries.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. API routes accessible at /api/calculate and /api/calculate/projection
3. `curl -X POST http://localhost:3000/api/calculate -H "Content-Type: application/json" -d '{"latitude":55.68,"longitude":12.57,"priceArea":"DK2","roofAreaM2":50,"azimuthDegrees":180,"tiltDegrees":35,"panelsCost":50000,"inverterCost":20000,"installationCost":30000,"mountingKitCost":10000,"electricityRateDkk":2.5,"selfConsumptionRate":0.7}'` returns JSON with serialized Decimal values
4. TanStack Query provider wraps app
</verification>

<success_criteria>
- /api/calculate returns setupCost, payback, and taxScenarios with all Decimal values as strings
- /api/calculate/projection returns 25-year forecast with serialized results
- PVGIS integration provides solar yield estimate with 24-hour caching
- TanStack Query configured for client-side data fetching
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-core-calculations/01-04-SUMMARY.md`
</output>
