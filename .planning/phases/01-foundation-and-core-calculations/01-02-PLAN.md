---
phase: 01-foundation
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/calculations/types.ts
  - lib/calculations/setupPricing.ts
  - lib/calculations/payback.ts
  - lib/calculations/co2Savings.ts
  - lib/calculations/__tests__/setupPricing.test.ts
  - lib/calculations/__tests__/payback.test.ts
  - lib/calculations/__tests__/co2Savings.test.ts
  - jest.config.js
  - tsconfig.json
autonomous: true

must_haves:
  truths:
    - "Payback calculation matches Excel reference values within 0.01 DKK"
    - "All calculations use Decimal.js (not floating-point)"
    - "CO2 savings calculated using Danish grid emission factor"
  artifacts:
    - path: "lib/calculations/payback.ts"
      provides: "Payback period calculation"
      exports: ["calculatePayback", "PaybackInput", "PaybackResult"]
    - path: "lib/calculations/setupPricing.ts"
      provides: "System cost breakdown with VAT"
      exports: ["calculateSetupCost", "SetupCostInput", "SetupCostResult"]
    - path: "lib/calculations/co2Savings.ts"
      provides: "CO2 savings calculation"
      exports: ["calculateCO2Savings"]
  key_links:
    - from: "lib/calculations/payback.ts"
      to: "decimal.js"
      via: "import Decimal"
      pattern: "import.*Decimal.*from.*decimal\\.js"
---

<objective>
Create core calculation modules using TDD with Decimal.js for financial precision.

Purpose: Port Excel formulas to TypeScript with exact decimal precision. These calculations are the foundation of user trust - homeowners making 100K+ DKK decisions will verify results manually.

Output: Three tested calculation modules matching Excel reference values: setupPricing, payback, co2Savings.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-and-core-calculations/01-RESEARCH.md
@.planning/phases/01-foundation-and-core-calculations/CONTEXT.md

@lib/calculations.ts (existing calculations to port)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Jest testing infrastructure and shared types</name>
  <files>
    jest.config.js
    tsconfig.json
    lib/calculations/types.ts
  </files>
  <action>
Create jest.config.js for TypeScript testing:
```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/lib'],
  testMatch: ['**/__tests__/**/*.test.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1'
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js']
};
```

Create jest.setup.js:
```javascript
// Configure Decimal.js for consistent test behavior
const Decimal = require('decimal.js');
Decimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_UP });
```

Update package.json scripts (if not present):
```json
"test": "jest",
"test:watch": "jest --watch"
```

Install Jest dependencies:
```bash
npm install -D jest ts-jest @types/jest
```

Create lib/calculations/types.ts with shared types:
```typescript
import Decimal from 'decimal.js';

// Configure Decimal.js globally for financial calculations
Decimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_UP });

// Danish electricity constants
export const DANISH_VAT_RATE = new Decimal('0.25'); // 25% VAT
export const DANISH_GRID_CO2_KG_PER_KWH = new Decimal('0.5'); // Danish grid average
export const DEFAULT_SELF_CONSUMPTION = new Decimal('0.7'); // 70% typical
export const DEFAULT_GRID_FEED_IN_RATIO = new Decimal('0.8'); // 80% of retail rate

// Location input (for PVGIS integration)
export interface LocationInput {
  latitude: Decimal;
  longitude: Decimal;
  priceArea: 'DK1' | 'DK2';
}

// Roof parameters
export interface RoofInput {
  areaM2: Decimal;
  azimuthDegrees: Decimal; // 0 = North, 90 = East, 180 = South, 270 = West
  tiltDegrees: Decimal;    // 0 = flat, 90 = vertical
}

// Helper: Create Decimal from string (for clean test code)
export function d(value: string | number): Decimal {
  return new Decimal(value);
}
```
  </action>
  <verify>
Run `npx jest --version` to confirm Jest installed.
Run `npx tsc --noEmit` to verify types.ts compiles.
  </verify>
  <done>
Jest configured for TypeScript. Shared calculation types defined with Decimal.js constants for Danish market.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD - Setup Pricing module (RED-GREEN-REFACTOR)</name>
  <files>
    lib/calculations/__tests__/setupPricing.test.ts
    lib/calculations/setupPricing.ts
  </files>
  <action>
**RED PHASE:** Create failing test first.

Create lib/calculations/__tests__/setupPricing.test.ts:
```typescript
import Decimal from 'decimal.js';
import { calculateSetupCost, SetupCostInput } from '../setupPricing';
import { d } from '../types';

describe('Setup Pricing (Setup & Price sheet)', () => {
  // Snapshot test: Values from Excel "Setup & Price" sheet
  it('matches Excel for reference installation', () => {
    const input: SetupCostInput = {
      panelsCost: d('47400'),      // From Excel
      inverterCost: d('20625'),
      installationCost: d('49335'),
      mountingKitCost: d('11680'),
    };

    const result = calculateSetupCost(input);

    // Excel values (before VAT)
    expect(result.subtotal.toFixed(2)).toBe('129040.00');
    // With 25% VAT
    expect(result.vatAmount.toFixed(2)).toBe('32260.00');
    expect(result.totalWithVat.toFixed(2)).toBe('161300.00');
  });

  it('handles zero costs', () => {
    const input: SetupCostInput = {
      panelsCost: d('0'),
      inverterCost: d('0'),
      installationCost: d('0'),
      mountingKitCost: d('0'),
    };

    const result = calculateSetupCost(input);

    expect(result.totalWithVat.toFixed(2)).toBe('0.00');
  });

  it('calculates VAT correctly at 25%', () => {
    const input: SetupCostInput = {
      panelsCost: d('100000'),
      inverterCost: d('0'),
      installationCost: d('0'),
      mountingKitCost: d('0'),
    };

    const result = calculateSetupCost(input);

    expect(result.vatAmount.toFixed(2)).toBe('25000.00');
    expect(result.totalWithVat.toFixed(2)).toBe('125000.00');
  });
});
```

Run test - should FAIL (module doesn't exist yet).

**GREEN PHASE:** Create minimal implementation.

Create lib/calculations/setupPricing.ts:
```typescript
import Decimal from 'decimal.js';
import { DANISH_VAT_RATE } from './types';

export interface SetupCostInput {
  panelsCost: Decimal;
  inverterCost: Decimal;
  installationCost: Decimal;
  mountingKitCost: Decimal;
  batteryCost?: Decimal; // Optional for Phase 5
}

export interface SetupCostResult {
  panelsCost: Decimal;
  inverterCost: Decimal;
  installationCost: Decimal;
  mountingKitCost: Decimal;
  batteryCost: Decimal;
  subtotal: Decimal;
  vatRate: Decimal;
  vatAmount: Decimal;
  totalWithVat: Decimal;
}

/**
 * Calculate system setup cost with VAT breakdown
 * Mirrors "Setup & Price" Excel sheet
 */
export function calculateSetupCost(input: SetupCostInput): SetupCostResult {
  const batteryCost = input.batteryCost ?? new Decimal(0);

  const subtotal = input.panelsCost
    .plus(input.inverterCost)
    .plus(input.installationCost)
    .plus(input.mountingKitCost)
    .plus(batteryCost);

  const vatAmount = subtotal.times(DANISH_VAT_RATE);
  const totalWithVat = subtotal.plus(vatAmount);

  return {
    panelsCost: input.panelsCost,
    inverterCost: input.inverterCost,
    installationCost: input.installationCost,
    mountingKitCost: input.mountingKitCost,
    batteryCost,
    subtotal,
    vatRate: DANISH_VAT_RATE,
    vatAmount,
    totalWithVat,
  };
}
```

Run test - should PASS.

**REFACTOR:** Review for clarity, add JSDoc if needed.
  </action>
  <verify>
Run `npm test -- setupPricing` - all tests pass.
  </verify>
  <done>
Setup pricing module passes all tests including Excel snapshot comparison. VAT calculation verified at 25%.
  </done>
</task>

<task type="auto">
  <name>Task 3: TDD - Payback module with property-based tests (RED-GREEN-REFACTOR)</name>
  <files>
    lib/calculations/__tests__/payback.test.ts
    lib/calculations/payback.ts
  </files>
  <action>
**RED PHASE:** Create failing tests including property-based tests.

Create lib/calculations/__tests__/payback.test.ts:
```typescript
import Decimal from 'decimal.js';
import fc from 'fast-check';
import { calculatePayback, PaybackInput } from '../payback';
import { d } from '../types';

describe('Payback Calculation (Yearly Payback Overview sheet)', () => {
  // Snapshot: Values from Excel
  it('matches Excel for reference installation', () => {
    const input: PaybackInput = {
      systemCost: d('161300'),       // Total with VAT from Setup & Price
      annualProductionKwh: d('8800'), // From PVGIS estimate
      electricityRate: d('2.50'),     // DKK/kWh
      selfConsumptionRate: d('0.70'), // 70%
      gridFeedInRate: d('2.00'),      // 80% of retail
    };

    const result = calculatePayback(input);

    // Excel: Annual savings = (8800 * 0.7 * 2.50) + (8800 * 0.3 * 2.00)
    //                       = 15400 + 5280 = 20680 DKK
    expect(result.annualSavings.toFixed(2)).toBe('20680.00');

    // Payback = 161300 / 20680 = 7.80 years
    expect(result.paybackYears.toFixed(2)).toBe('7.80');
    expect(result.breakEvenYear).toBe(8);
  });

  it('matches Excel for low self-consumption scenario', () => {
    const input: PaybackInput = {
      systemCost: d('85000'),
      annualProductionKwh: d('4200'),
      electricityRate: d('3.20'),
      selfConsumptionRate: d('0.40'),
      gridFeedInRate: d('2.56'),
    };

    const result = calculatePayback(input);

    // (4200 * 0.4 * 3.20) + (4200 * 0.6 * 2.56) = 5376 + 6451.2 = 11827.2
    expect(result.annualSavings.toFixed(2)).toBe('11827.20');
  });

  // Property-based tests
  describe('mathematical properties', () => {
    it('payback decreases as electricity rate increases', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 50000, max: 200000 }),
          fc.integer({ min: 3000, max: 15000 }),
          fc.float({ min: 1.5, max: 3.0 }),
          fc.float({ min: 3.5, max: 6.0 }),
          (cost, production, rate1, rate2) => {
            const baseInput = {
              systemCost: new Decimal(cost),
              annualProductionKwh: new Decimal(production),
              selfConsumptionRate: new Decimal('0.7'),
            };

            const result1 = calculatePayback({
              ...baseInput,
              electricityRate: new Decimal(rate1),
              gridFeedInRate: new Decimal(rate1).times('0.8'),
            });

            const result2 = calculatePayback({
              ...baseInput,
              electricityRate: new Decimal(rate2),
              gridFeedInRate: new Decimal(rate2).times('0.8'),
            });

            // Higher rate = more savings = shorter payback
            return result2.paybackYears.lessThan(result1.paybackYears);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('payback is always positive and finite', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 10000, max: 500000 }),
          fc.integer({ min: 1000, max: 20000 }),
          fc.float({ min: 0.5, max: 10.0 }),
          fc.float({ min: 0.3, max: 1.0 }),
          (cost, production, rate, selfConsumption) => {
            const result = calculatePayback({
              systemCost: new Decimal(cost),
              annualProductionKwh: new Decimal(production),
              electricityRate: new Decimal(rate),
              selfConsumptionRate: new Decimal(selfConsumption),
              gridFeedInRate: new Decimal(rate).times('0.8'),
            });

            return result.paybackYears.isFinite() &&
                   result.paybackYears.greaterThan(0);
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
```

**GREEN PHASE:** Create implementation.

Create lib/calculations/payback.ts:
```typescript
import Decimal from 'decimal.js';

export interface PaybackInput {
  systemCost: Decimal;
  annualProductionKwh: Decimal;
  electricityRate: Decimal;       // DKK/kWh
  selfConsumptionRate: Decimal;   // 0.0 to 1.0
  gridFeedInRate: Decimal;        // DKK/kWh for exported electricity
}

export interface PaybackResult {
  annualSavings: Decimal;
  selfConsumptionSavings: Decimal;
  gridExportEarnings: Decimal;
  paybackYears: Decimal;
  breakEvenYear: number;
}

/**
 * Calculate simple payback period for solar installation
 * Mirrors "Yearly Payback Overview" Excel sheet logic
 */
export function calculatePayback(input: PaybackInput): PaybackResult {
  // Self-consumed electricity savings
  const selfConsumedKwh = input.annualProductionKwh.times(input.selfConsumptionRate);
  const selfConsumptionSavings = selfConsumedKwh.times(input.electricityRate);

  // Grid export earnings
  const exportedKwh = input.annualProductionKwh.times(
    new Decimal(1).minus(input.selfConsumptionRate)
  );
  const gridExportEarnings = exportedKwh.times(input.gridFeedInRate);

  // Total annual savings
  const annualSavings = selfConsumptionSavings.plus(gridExportEarnings);

  // Simple payback period (years)
  const paybackYears = input.systemCost.dividedBy(annualSavings);

  // Break-even year (first full year with positive cumulative)
  const breakEvenYear = paybackYears.ceil().toNumber();

  return {
    annualSavings,
    selfConsumptionSavings,
    gridExportEarnings,
    paybackYears,
    breakEvenYear,
  };
}
```

Run tests - should PASS.
  </action>
  <verify>
Run `npm test -- payback` - all tests pass including property-based tests.
  </verify>
  <done>
Payback module passes snapshot tests matching Excel values and 100+ property-based test cases verifying mathematical correctness.
  </done>
</task>

</tasks>

<verification>
1. `npm test` runs all tests successfully
2. Snapshot tests match Excel reference values within 0.01 DKK
3. Property-based tests run 100+ scenarios each without failure
4. All calculations import and use Decimal from decimal.js
</verification>

<success_criteria>
- setupPricing.ts exports calculateSetupCost matching Excel "Setup & Price" sheet
- payback.ts exports calculatePayback matching Excel "Yearly Payback Overview" sheet
- All modules use Decimal.js (no floating-point arithmetic for money)
- Property-based tests verify mathematical invariants
- Jest test suite configured and passing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-core-calculations/01-02-SUMMARY.md`
</output>
