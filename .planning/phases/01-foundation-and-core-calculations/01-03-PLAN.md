---
phase: 01-foundation
plan: 03
type: tdd
wave: 2
depends_on: ["01-02"]
files_modified:
  - lib/calculations/projection.ts
  - lib/calculations/taxScenarios.ts
  - lib/calculations/__tests__/projection.test.ts
  - lib/calculations/__tests__/taxScenarios.test.ts
autonomous: true

must_haves:
  truths:
    - "25-year projection accounts for panel degradation (3% year 1, 0.5%/year after)"
    - "Projection shows both nominal and inflation-adjusted (real) savings"
    - "Tax scenario models Danish home improvement deduction rules"
  artifacts:
    - path: "lib/calculations/projection.ts"
      provides: "25-year financial projection"
      exports: ["calculateProjection", "ProjectionResult", "YearResult"]
    - path: "lib/calculations/taxScenarios.ts"
      provides: "Tax deduction scenarios"
      exports: ["calculateTaxScenario", "TaxScenarioInput"]
  key_links:
    - from: "lib/calculations/projection.ts"
      to: "lib/calculations/payback.ts"
      via: "uses annual savings calculation"
      pattern: "import.*from.*payback"
---

<objective>
Create 25-year projection module with inflation adjustment and tax scenarios using TDD.

Purpose: Long-term financial projections are the key differentiator. Users need to see how savings compound over 25 years with realistic degradation, inflation, and tax benefits. This is the "aha moment" that justifies a 100K+ DKK investment.

Output: Two tested modules - projection (25-year forecast) and taxScenarios (Danish tax deduction modeling).
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-and-core-calculations/01-RESEARCH.md
@.planning/phases/01-foundation-and-core-calculations/CONTEXT.md

@lib/calculations/payback.ts (from Plan 02)
@lib/calculations/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - 25-Year Projection module with degradation and inflation</name>
  <files>
    lib/calculations/__tests__/projection.test.ts
    lib/calculations/projection.ts
  </files>
  <action>
**RED PHASE:** Create failing tests.

Create lib/calculations/__tests__/projection.test.ts:
```typescript
import Decimal from 'decimal.js';
import fc from 'fast-check';
import { calculateProjection, ProjectionInput, YearResult } from '../projection';
import { d } from '../types';

describe('25-Year Projection (Financial Projection)', () => {
  const defaultInput: ProjectionInput = {
    systemCost: d('161300'),
    annualProductionKwh: d('8800'),
    electricityRateDkk: d('2.50'),
    selfConsumptionRate: d('0.70'),
    gridFeedInRate: d('2.00'),
    inflationRate: d('0.02'),           // 2% general inflation
    electricityInflationRate: d('0.03'), // 3% electricity inflation
    maintenanceCostYear1: d('1000'),     // 1000 DKK/year maintenance
    degradationRateFirstYear: d('0.03'), // 3% LID
    degradationRateAnnual: d('0.005'),   // 0.5%/year after
  };

  it('calculates 25 years of projections', () => {
    const result = calculateProjection(defaultInput);

    expect(result.years).toHaveLength(25);
    expect(result.years[0].year).toBe(1);
    expect(result.years[24].year).toBe(25);
  });

  describe('degradation modeling', () => {
    it('applies 3% first-year degradation (LID)', () => {
      const result = calculateProjection(defaultInput);

      // Year 1: 8800 * 0.97 = 8536 kWh
      expect(result.years[0].productionKwh.toFixed(0)).toBe('8536');
    });

    it('applies 0.5% annual degradation after year 1', () => {
      const result = calculateProjection(defaultInput);

      // Year 2: 8536 * 0.995 = 8493.32 kWh
      expect(result.years[1].productionKwh.toFixed(2)).toBe('8493.32');

      // Year 25: 8536 * 0.995^24 = 7562.67 kWh
      expect(result.years[24].productionKwh.toFixed(2)).toBe('7562.67');
    });
  });

  describe('inflation adjustment', () => {
    it('calculates both nominal and real savings', () => {
      const result = calculateProjection(defaultInput);

      // Year 10 electricity rate: 2.50 * 1.03^9 = 3.26 DKK/kWh
      // Nominal savings increase with electricity inflation
      // Real savings discount back to today's value

      const year10 = result.years[9];
      expect(year10.electricityRate.greaterThan(d('3.0'))).toBe(true);

      // Real savings should be less than nominal (inflation discount)
      expect(year10.savingsReal.lessThan(year10.savingsNominal)).toBe(true);
    });

    it('tracks cumulative savings correctly', () => {
      const result = calculateProjection(defaultInput);

      // Year 1 cumulative starts at (first year savings - system cost)
      expect(result.years[0].cumulativeNominal.lessThan(d('0'))).toBe(true);

      // Eventually goes positive (break-even)
      const breakEvenYear = result.years.findIndex(y =>
        y.cumulativeNominal.greaterThanOrEqualTo(d('0'))
      );
      expect(breakEvenYear).toBeGreaterThan(0);
      expect(breakEvenYear).toBeLessThan(15); // Should break even within 15 years
    });
  });

  describe('summary calculations', () => {
    it('calculates total lifetime savings', () => {
      const result = calculateProjection(defaultInput);

      // 25-year total should be substantial
      expect(result.summary.totalSavingsNominal.greaterThan(d('400000'))).toBe(true);
      expect(result.summary.totalSavingsReal.greaterThan(d('300000'))).toBe(true);
    });

    it('identifies break-even year', () => {
      const result = calculateProjection(defaultInput);

      expect(result.summary.breakEvenYearNominal).toBeGreaterThan(0);
      expect(result.summary.breakEvenYearNominal).toBeLessThanOrEqual(25);
    });
  });

  // Property-based tests
  describe('mathematical properties', () => {
    it('cumulative savings always increase year-over-year (after break-even)', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 50000, max: 200000 }),
          fc.integer({ min: 5000, max: 15000 }),
          fc.float({ min: 2.0, max: 5.0 }),
          (cost, production, rate) => {
            const result = calculateProjection({
              ...defaultInput,
              systemCost: new Decimal(cost),
              annualProductionKwh: new Decimal(production),
              electricityRateDkk: new Decimal(rate),
            });

            // After break-even, cumulative should always increase
            const breakEvenIdx = result.years.findIndex(y =>
              y.cumulativeNominal.greaterThanOrEqualTo(0)
            );

            if (breakEvenIdx >= 0 && breakEvenIdx < 24) {
              for (let i = breakEvenIdx; i < 24; i++) {
                if (!result.years[i + 1].cumulativeNominal
                    .greaterThan(result.years[i].cumulativeNominal)) {
                  return false;
                }
              }
            }
            return true;
          }
        ),
        { numRuns: 50 }
      );
    });
  });
});
```

**GREEN PHASE:** Create implementation.

Create lib/calculations/projection.ts:
```typescript
import Decimal from 'decimal.js';

export interface ProjectionInput {
  systemCost: Decimal;
  annualProductionKwh: Decimal;
  electricityRateDkk: Decimal;
  selfConsumptionRate: Decimal;
  gridFeedInRate: Decimal;
  inflationRate: Decimal;
  electricityInflationRate: Decimal;
  maintenanceCostYear1: Decimal;
  degradationRateFirstYear: Decimal;
  degradationRateAnnual: Decimal;
}

export interface YearResult {
  year: number;
  productionKwh: Decimal;
  electricityRate: Decimal;
  gridFeedInRate: Decimal;
  selfConsumptionSavings: Decimal;
  gridExportEarnings: Decimal;
  savingsNominal: Decimal;
  savingsReal: Decimal;
  maintenanceCost: Decimal;
  netSavingsNominal: Decimal;
  netSavingsReal: Decimal;
  cumulativeNominal: Decimal;
  cumulativeReal: Decimal;
}

export interface ProjectionSummary {
  totalSavingsNominal: Decimal;
  totalSavingsReal: Decimal;
  totalMaintenanceCost: Decimal;
  breakEvenYearNominal: number;
  breakEvenYearReal: number;
  roi25Year: Decimal; // Percentage
}

export interface ProjectionResult {
  years: YearResult[];
  summary: ProjectionSummary;
}

/**
 * Calculate 25-year financial projection with degradation and inflation
 *
 * Key assumptions:
 * - Year 1: 3% LID (light-induced degradation)
 * - Years 2-25: 0.5%/year degradation
 * - Electricity rates inflate at electricityInflationRate
 * - Maintenance costs inflate at general inflationRate
 * - Real values discounted by general inflationRate
 */
export function calculateProjection(input: ProjectionInput): ProjectionResult {
  const years: YearResult[] = [];
  let cumulativeNominal = input.systemCost.negated();
  let cumulativeReal = input.systemCost.negated();
  let breakEvenYearNominal = 0;
  let breakEvenYearReal = 0;
  let totalSavingsNominal = new Decimal(0);
  let totalSavingsReal = new Decimal(0);
  let totalMaintenanceCost = new Decimal(0);

  for (let year = 1; year <= 25; year++) {
    // Production with degradation
    let production: Decimal;
    if (year === 1) {
      production = input.annualProductionKwh.times(
        new Decimal(1).minus(input.degradationRateFirstYear)
      );
    } else {
      const year1Production = input.annualProductionKwh.times(
        new Decimal(1).minus(input.degradationRateFirstYear)
      );
      production = year1Production.times(
        new Decimal(1).minus(input.degradationRateAnnual).pow(year - 1)
      );
    }

    // Electricity rate with inflation
    const electricityRate = input.electricityRateDkk.times(
      new Decimal(1).plus(input.electricityInflationRate).pow(year - 1)
    );
    const gridFeedInRate = input.gridFeedInRate.times(
      new Decimal(1).plus(input.electricityInflationRate).pow(year - 1)
    );

    // Savings calculation
    const selfConsumedKwh = production.times(input.selfConsumptionRate);
    const exportedKwh = production.times(
      new Decimal(1).minus(input.selfConsumptionRate)
    );

    const selfConsumptionSavings = selfConsumedKwh.times(electricityRate);
    const gridExportEarnings = exportedKwh.times(gridFeedInRate);
    const savingsNominal = selfConsumptionSavings.plus(gridExportEarnings);

    // Savings in today's value
    const discountFactor = new Decimal(1).plus(input.inflationRate).pow(year - 1);
    const savingsReal = savingsNominal.dividedBy(discountFactor);

    // Maintenance cost (inflates with general inflation)
    const maintenanceCost = input.maintenanceCostYear1.times(
      new Decimal(1).plus(input.inflationRate).pow(year - 1)
    );
    const maintenanceReal = input.maintenanceCostYear1;

    // Net savings
    const netSavingsNominal = savingsNominal.minus(maintenanceCost);
    const netSavingsReal = savingsReal.minus(maintenanceReal);

    // Cumulative
    cumulativeNominal = cumulativeNominal.plus(netSavingsNominal);
    cumulativeReal = cumulativeReal.plus(netSavingsReal);

    // Track break-even
    if (breakEvenYearNominal === 0 && cumulativeNominal.greaterThanOrEqualTo(0)) {
      breakEvenYearNominal = year;
    }
    if (breakEvenYearReal === 0 && cumulativeReal.greaterThanOrEqualTo(0)) {
      breakEvenYearReal = year;
    }

    // Totals
    totalSavingsNominal = totalSavingsNominal.plus(netSavingsNominal);
    totalSavingsReal = totalSavingsReal.plus(netSavingsReal);
    totalMaintenanceCost = totalMaintenanceCost.plus(maintenanceCost);

    years.push({
      year,
      productionKwh: production,
      electricityRate,
      gridFeedInRate,
      selfConsumptionSavings,
      gridExportEarnings,
      savingsNominal,
      savingsReal,
      maintenanceCost,
      netSavingsNominal,
      netSavingsReal,
      cumulativeNominal,
      cumulativeReal,
    });
  }

  // ROI: (Total profit / Investment) * 100
  const roi25Year = totalSavingsNominal.dividedBy(input.systemCost).times(100);

  return {
    years,
    summary: {
      totalSavingsNominal,
      totalSavingsReal,
      totalMaintenanceCost,
      breakEvenYearNominal,
      breakEvenYearReal,
      roi25Year,
    },
  };
}

/**
 * Format projection for Recharts (Decimal -> number)
 */
export function formatProjectionForChart(result: ProjectionResult) {
  return result.years.map(y => ({
    year: y.year,
    savingsNominal: y.netSavingsNominal.toNumber(),
    savingsReal: y.netSavingsReal.toNumber(),
    cumulativeNominal: y.cumulativeNominal.toNumber(),
    cumulativeReal: y.cumulativeReal.toNumber(),
    productionKwh: y.productionKwh.toNumber(),
  }));
}
```

Run tests - should PASS.
  </action>
  <verify>
Run `npm test -- projection` - all tests pass.
  </verify>
  <done>
25-year projection module calculates degraded production, inflation-adjusted savings, and tracks break-even point. Both nominal and real values provided for transparency.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD - Tax Scenarios module for Danish deductions</name>
  <files>
    lib/calculations/__tests__/taxScenarios.test.ts
    lib/calculations/taxScenarios.ts
  </files>
  <action>
**RED PHASE:** Create failing tests.

Create lib/calculations/__tests__/taxScenarios.test.ts:
```typescript
import Decimal from 'decimal.js';
import { calculateTaxScenario, TaxScenarioInput, TaxScenarioType } from '../taxScenarios';
import { d } from '../types';

describe('Tax Scenarios (Danish Tax Deductions)', () => {
  const baseInput: TaxScenarioInput = {
    systemCost: d('161300'),          // Total with VAT
    installationLaborCost: d('49335'), // Labor portion only
    panelsCost: d('47400'),
    inverterCost: d('20625'),
    annualSavings: d('20680'),
  };

  describe('NO_TAX scenario', () => {
    it('returns original values without deduction', () => {
      const result = calculateTaxScenario(baseInput, 'NO_TAX');

      expect(result.scenario).toBe('NO_TAX');
      expect(result.effectiveCost.equals(baseInput.systemCost)).toBe(true);
      expect(result.taxDeduction.equals(d('0'))).toBe(true);
    });
  });

  describe('LABOR_DEDUCTION scenario', () => {
    it('applies deduction only to labor costs', () => {
      const result = calculateTaxScenario(baseInput, 'LABOR_DEDUCTION');

      expect(result.scenario).toBe('LABOR_DEDUCTION');
      // Deduction is on labor only, not equipment
      expect(result.eligibleAmount.equals(baseInput.installationLaborCost)).toBe(true);
      // Deduction rate (placeholder - needs 2026 SKAT rules)
      expect(result.taxDeduction.greaterThan(d('0'))).toBe(true);
    });

    it('caps deduction at maximum allowed', () => {
      const expensiveLabor: TaxScenarioInput = {
        ...baseInput,
        installationLaborCost: d('500000'), // Very expensive labor
      };

      const result = calculateTaxScenario(expensiveLabor, 'LABOR_DEDUCTION');

      // Should be capped at max deduction
      expect(result.taxDeduction.lessThanOrEqualTo(result.maxDeduction)).toBe(true);
    });
  });

  describe('effective payback comparison', () => {
    it('shows lower effective cost with tax deduction', () => {
      const noTax = calculateTaxScenario(baseInput, 'NO_TAX');
      const withTax = calculateTaxScenario(baseInput, 'LABOR_DEDUCTION');

      expect(withTax.effectiveCost.lessThan(noTax.effectiveCost)).toBe(true);
      expect(withTax.effectivePaybackYears.lessThan(noTax.effectivePaybackYears)).toBe(true);
    });
  });

  it('documents assumptions for transparency (FIN-06)', () => {
    const result = calculateTaxScenario(baseInput, 'LABOR_DEDUCTION');

    expect(result.assumptions).toContain('Danish home improvement deduction');
    expect(result.assumptions.length).toBeGreaterThan(0);
  });
});
```

**GREEN PHASE:** Create implementation.

Create lib/calculations/taxScenarios.ts:
```typescript
import Decimal from 'decimal.js';

export type TaxScenarioType = 'NO_TAX' | 'LABOR_DEDUCTION';

export interface TaxScenarioInput {
  systemCost: Decimal;
  installationLaborCost: Decimal;
  panelsCost: Decimal;
  inverterCost: Decimal;
  annualSavings: Decimal;
}

export interface TaxScenarioResult {
  scenario: TaxScenarioType;
  eligibleAmount: Decimal;
  deductionRate: Decimal;
  taxDeduction: Decimal;
  maxDeduction: Decimal;
  effectiveCost: Decimal;
  effectivePaybackYears: Decimal;
  assumptions: string[];
}

// Danish tax deduction constants (2026 placeholder - needs SKAT verification)
// These are ESTIMATES based on historical håndværkerfradrag patterns
const LABOR_DEDUCTION_RATE = new Decimal('0.26'); // ~26% tax value of deduction
const MAX_DEDUCTION_DKK = new Decimal('25000');   // Annual cap (placeholder)

/**
 * Calculate tax scenario for solar installation
 *
 * IMPORTANT: These values are placeholders. Verify with SKAT 2026 guidelines
 * before production use. Danish tax rules change annually.
 *
 * @param input - Cost breakdown and annual savings
 * @param scenario - Tax scenario to calculate
 */
export function calculateTaxScenario(
  input: TaxScenarioInput,
  scenario: TaxScenarioType
): TaxScenarioResult {
  const baseAssumptions = [
    'Danish home improvement deduction (håndværkerfradrag) rules',
    'Standard tax bracket assumed',
    'Single-year deduction (not spread across years)',
  ];

  if (scenario === 'NO_TAX') {
    return {
      scenario,
      eligibleAmount: new Decimal(0),
      deductionRate: new Decimal(0),
      taxDeduction: new Decimal(0),
      maxDeduction: new Decimal(0),
      effectiveCost: input.systemCost,
      effectivePaybackYears: input.systemCost.dividedBy(input.annualSavings),
      assumptions: ['No tax deduction applied'],
    };
  }

  // LABOR_DEDUCTION scenario
  const eligibleAmount = input.installationLaborCost;

  // Calculate tax deduction (capped at max)
  const rawDeduction = eligibleAmount.times(LABOR_DEDUCTION_RATE);
  const taxDeduction = Decimal.min(rawDeduction, MAX_DEDUCTION_DKK);

  // Effective cost after deduction
  const effectiveCost = input.systemCost.minus(taxDeduction);

  // Effective payback with lower cost
  const effectivePaybackYears = effectiveCost.dividedBy(input.annualSavings);

  return {
    scenario,
    eligibleAmount,
    deductionRate: LABOR_DEDUCTION_RATE,
    taxDeduction,
    maxDeduction: MAX_DEDUCTION_DKK,
    effectiveCost,
    effectivePaybackYears,
    assumptions: [
      ...baseAssumptions,
      `Deduction rate: ${LABOR_DEDUCTION_RATE.times(100).toFixed(0)}% tax value`,
      `Maximum deduction: ${MAX_DEDUCTION_DKK.toFixed(0)} DKK`,
      'Deduction applies to labor costs only (not equipment)',
      'PLACEHOLDER VALUES - Verify with SKAT 2026 rules before use',
    ],
  };
}

/**
 * Compare multiple tax scenarios side-by-side
 */
export function compareTaxScenarios(input: TaxScenarioInput): TaxScenarioResult[] {
  const scenarios: TaxScenarioType[] = ['NO_TAX', 'LABOR_DEDUCTION'];
  return scenarios.map(s => calculateTaxScenario(input, s));
}
```

Run tests - should PASS.
  </action>
  <verify>
Run `npm test -- taxScenarios` - all tests pass.
  </verify>
  <done>
Tax scenarios module calculates Danish home improvement deduction effects on payback. Includes prominent assumptions documentation for transparency (FIN-06). Values marked as placeholders pending 2026 SKAT verification.
  </done>
</task>

</tasks>

<verification>
1. `npm test` runs all projection and tax tests successfully
2. 25-year projection produces 25 YearResult objects with degradation curve
3. Both nominal and real (inflation-adjusted) values calculated
4. Tax scenarios show effective cost reduction with deduction
5. All results include documented assumptions
</verification>

<success_criteria>
- projection.ts produces 25-year forecast with degradation and inflation
- taxScenarios.ts models Danish tax deduction with clear assumptions
- Property tests verify cumulative savings increase after break-even
- All assumptions documented in results for FIN-06 transparency
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-core-calculations/01-03-SUMMARY.md`
</output>
